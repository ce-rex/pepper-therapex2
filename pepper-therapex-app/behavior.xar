<?xml version="1.0" encoding="UTF-8" ?><ChoregrapheProject xmlns="http://www.aldebaran-robotics.com/schema/choregraphe/project.xsd" xar_version="3"><Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0"><bitmap>media/images/box/root.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram scale="84.0896"><Box name="exercise manager" id="12" localization="8" tooltip="" x="149" y="42"><bitmap>media/images/box/box-python-script.png</bitmap><script language="4"><content><![CDATA[import threading
import socket
import json
import numpy as np
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.manager = None

    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        self.exercise_manager = ExerciseManager(self.session(), self.logger, self.behaviorAbsolutePath(), virtual=False)
        self.logger.info(self.behaviorAbsolutePath())
        ex_runtime = 20  #40
        num_exercises = 1  #6
        session_runtime = ex_runtime * num_exercises
        sessions = 2  #2

        # SET PLAYLIST
        #playlist = [[SONGS[10], SONGS[4]], [SONGS[10], SONGS[4]]]
        playlist = [["/songs/blindinglights.wav", "/songs/feel_it_still.wav"],
                    ["/songs/destination_calabria.wav", "/songs/rhythm_is_a_dancer.wav"]]

        # MOTIVATIONAL PHRASES
        #self.exercise_manager.robot.play_song(playlist[1][1])
        # time.sleep(5)
        self.exercise_manager.robot.stop_song()

        # STANDBY SCREEN
        self.logger.info("waiting for touch")
        while self.exercise_manager.robot.waiting_for_touch:
            time.sleep(1)
        self.logger.info("touched!")
        #time.sleep(10)

        # RESTING BPM CALIBRATION
        self.exercise_manager.start_calibration()

        # SESSIONS
        for session in range(sessions):
            # - MUSIC
            self.thread_music = threading.Thread(target=self.play_music, args=(playlist[session], session_runtime))
            self.thread_music.start()

            # - MOTIVATIONAL PHRASES - outdated
            #thread_speech = threading.Thread(target=say_motivational_phrases, args=(session_runtime,))
            #thread_speech.start()

            # START HEART RATE MONITORING
            self.exercise_running = True
            self.thread_monitoring_resume = threading.Event()
            self.thread_monitoring = threading.Thread(target=self.run_data_update)
            self.thread_monitoring.start()
            self.thread_monitoring_resume.set()

            # self.manager.robot.play_song("/songs/blindinglights.wav")
            # self.manager.stop_everything()
            # self.manager.update_data()
            counter = 0
            first_exercise_of_session = True

            while counter < num_exercises:
                counter = counter + 1
                self.logger.info("This is session %s exercise %s", session+1, counter+1)

                # send exercise intensity to raspi server
                # always 1 (UP) for first exercise of session
                if first_exercise_of_session:
                    self.exercise_manager.data_client.call_with_data("intensity", 1)
                    first_exercise_of_session = False

                # START EXERCISE
                self.exercise_manager.play_exercise(ex_runtime)

                # EVALUATE BPM and adjust exercise intensity
                self.thread_monitoring_resume.clear()  # stop updating data
                time.sleep(0.1)
                self.exercise_manager.evaluate_bpm()
                self.logger.info("checkpoint 1")
                self.thread_monitoring_resume.set()  # resume updating data

            # STOP MUSIC AND MOTIVATIONAL SPEECH
            self.logger.info("checkpoint 2")
            self.exercise_manager.robot.stop_song()
            self.exercise_manager.robot.stop_song()
            self.logger.info("checkpoint 3")
            self.thread_music.join()
            #thread_speech.join() - outdated
            self.exercise_running = False
            self.thread_monitoring.join()
            self.logger.info("checkpoint 4")
            time.sleep(3)
            if session < sessions - 1:  # if it was not the last session
                self.exercise_manager.end_session(is_last_session=False)
            else:
                self.exercise_manager.end_session(is_last_session=True)

            # RESTING PHASE AFTER FIRST SESSION
            if session == 0:
                self.exercise_manager.start_resting_phase()

        # SAY GOODBYE AND STOP EVERYTHING
        thread_goodbye = threading.Thread(target=self.exercise_manager.say_goodbye)
        thread_goodbye.start()

        self.exercise_manager.stop_everything()

        self.onStopped() #activate the output of the box

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.exercise_manager.stop_everything()
        self.exercise_running = False
        self.thread_monitoring.join()
        self.exercise_manager.robot.stop_song()
        self.thread_music.join()
        self.onStopped() #activate the output of the box

    def run_data_update(self):
        start = time.time()
        self.logger.info("start requesting data!")
        #while time.time() - start < duration:
        while self.exercise_running:
            #self.logger.info("hi" + str(time.time() - start))
            self.logger.info("checkpoint 4.1")
            self.thread_monitoring_resume.wait()
            self.logger.info("checkpoint 4.2")
            self.exercise_manager.update_data()
            self.logger.info("checkpoint 4.3")
            time.sleep(0.1)

        self.logger.info("stop requesting data!")

    def play_music1(self, playlist, duration):
        self.logger.info(playlist)
        start = time.time()
        for song in playlist:
            if time.time() - start < duration:
                self.logger.info("start playing song: " + song)
                self.exercise_manager.robot.play_song(song)

    def play_music(self, playlist, duration):
        self.logger.info(playlist)
        duration_left = self.exercise_manager.robot.play_song_with_duration(playlist[0], duration)
        if duration_left > 0:
            self.exercise_manager.robot.play_song_with_duration(playlist[1], duration_left)

    def say_motivational_phrases(duration):
        phrases = self.motivational_phrases
        random.shuffle(phrases)
        said_phrase = [False, False, False]

        start = time.time()

        if not said_phrase[0] and time.time() - start > duration / 3:
            self.exercise_manager.robot.say(phrases.pop())
            said_phrase[0] = True

        if not said_phrase[1] and time.time() - start > duration * 3 / 4:
            self.exercise_manager.robot.say(phrases.pop())
            said_phrase[1] = True

        if not said_phrase[2] and time.time() - start > duration - 10:
            self.exercise_manager.robot.say(phrases.pop())
            said_phrase[2] = True

class ExerciseManager():
    def __init__(self, session, logger, behaviorAbsolutePath, virtual):
        self.logger = logger
        self.test = "asdga"
        self.robot = Pepper(session, logger, behaviorAbsolutePath, virtual)

        # init connection to data server
        self.data_client = DataClient(logger, behaviorAbsolutePath, virtual, data_port=5006, arg_port=5005)
        #self.data_client.call_for("start")
        self.data_client.call_with_data("start")

        self.virtual = virtual
        self.appName = ".lastUploadedChoregrapheBehavior"

        self.last_bpm = 0
        self.last20_bpm = np.arange(-20, 0)
        self.last20_bpm_variance = 100  # some number greater than 1

        self.current_intensity = 1  # exercise intensity can be 1 (easy), 2 (medium) or 3 (hard)
        self.intensity_trend = 1
        self.exercises = ["1_zen", "2_rolling", "3_serve", "4_wave", "5_chicken", "6_darja",
                        "7_punch_front", "8_punch_top", "9_punch_all", "9_punch_all2"]
        self.exercise_idx = 0
        self.easy_exerices = ExerciseList(logger, first_exercise_idx=0, last_exercise_idx=2)
        self.medium_exercises = ExerciseList(logger, first_exercise_idx=3, last_exercise_idx=5)
        self.hard_exercises = ExerciseList(logger, first_exercise_idx=6, last_exercise_idx=9)
        # b = [0, 1, 2]
        # np.random.seed(0)
        # np.random.shuffle(b)

        # motivational phrases
        self.midex_motivational_phrases = ["Almost there!",  # 0
            "Keep going!",  # 1
            "Remember to breathe!",  # 2
            "You are almost done!",  # 3
            "You can do \\vct=10\\\\rspd=150\\ it!",  # 4
            "You're doing great!",  # 5
            "Push through the burn!",  # 6
            "Stay focused and finish strong!",  # 7
            "Don't give up now, you're so close!",  # 8
            "Think of how amazing you'll feel when you're done!",  # 9
            "Keep that momentum going!",  # 10
            "The hard work will pay off, keep pushing!",  # 11
            "You're making progress with every move!",  # 12
            "Your determination is inspiring!",  # 13
            "You've got this, believe in yourself!",  # 14
            "Challenge yourself, you're capable of more than you know!",  # 15
            "One step at a time, you're getting closer to your goal!",  # 16
            "You're building strength and resilience with every rep!",  # 17
            "Keep up the fantastic effort, it's worth it!",  # 18
            "You've got this!" #19
            "You're a dance superstar!",
            "You're a dance warrior!",
            "Your moves are on fire! Keep dancing with passion and joy!",
            "You're unstoppable! Keep that positive energy flowing!",
            "You're doing great! Keep up the fantastic work!"
        ]

        self.postex_motivational_phrases = [
            "Well done!",
            "Good job!",
            "Excellent!",
            "Great!",
            "Wonderful!",
            "You did well!",
            "Perfect!",
            "Fantastic effort!",
            "Bravo! Keep it up!",
            "You're rocking it!",
            "Incredible work!",
            "You're unstoppable!",
            "Marvelous performance!",
            "Keep shining bright!",
            "You're a superstar!",
            "Impressive moves!",
            "You're on fire!",
            "Outstanding job!",
            "You're giving it your all!",
            "Unbelievable energy!",
            "Amazing job!"
        ]
        random.shuffle(self.midex_motivational_phrases)  # shuffle and pop is not so nice, but we have a lot of phrases left
        random.shuffle(self.postex_motivational_phrases)

    def update_data(self):
        # get new sensor data
        bpm, pulse_signal = self.data_client.call_for_data()

        if (not bpm == 0) or (not pulse_signal == 0):
            # self.logger.info("BPM: " + str(bpm) + "  ---  pulse signal: " + str(pulse_signal))

            # self.current_intensity = np.nan  # some random number


            # update tablet
            if pulse_signal != 0 or pulse_signal >= 680:
                self.robot.update_pulsewave(pulse_signal)

            if self.last_bpm != bpm:
                self.last20_bpm = np.append(self.last20_bpm, [bpm])
                self.last20_bpm = self.last20_bpm[1:]
                # update tablet
                self.robot.update_bpm(bpm)

                # update bpm tracker
                # self.last20_bpm = np.append(self.last20_bpm, [bpm])
                # self.last20_bpm = self.last20_bpm[1:]
                self.last20_bpm_variance = self.last20_bpm.var()
                #self.logger.info(self.last20_bpm)

                self.last_bpm = bpm

    def start_calibration(self):
        #self.robot.awareness_on()
        # tell participant to sit still and breathe while calibration
        self.robot.animated_say("Please sit still and breathe normally, while I am calibrating!")
        #self.robot.awareness_off()
        # start "calibration movement" e.g.  animations/Stand/Waiting/BreathLoop_1
        if not self.virtual:
            self.robot.behaviour.runBehavior("boot-config/animations/networkLoop", _async=True)

        # calc variance until the BPM is stable (variance < 1)
        self.logger.info("CALIBRATING...")
        while self.last20_bpm_variance > 10:  # 1.5 or 2
            self.update_data()
            if self.virtual:
                self.logger.info("BPM: " + str(self.last_bpm))
            #self.logger.info("VARIANCE: " + str(self.last20_bpm_variance))

        self.logger.info("EAR PIECE IS CALIBRATED!")

        # calc resting BPM
        self.resting_bpm = self.last20_bpm.mean()
        self.logger.info("RESTING BPM: " + str(self.resting_bpm))

        # send resting BPM to RaspberryPi (has to be below 100, only works with 2 digit numbers)
        self.data_client.call_with_data("resting_bpm", self.resting_bpm)

        # calc BPM boundaries
        self.lower_bound_bpm = self.resting_bpm * 1.2
        self.upper_bound_bpm = self.resting_bpm * 1.3
        self.logger.info("BPM boundaries: " + str(self.lower_bound_bpm) + " --- " + str(self.upper_bound_bpm))

        # update tablet
        # self.robot.update_bpm_boundaries(self.resting_bpm, self.lower_bound_bpm, self.upper_bound_bpm)

        # stop "calibration movement"
        if not self.virtual:
            # self.logger.info("I'M TRYING TO STOP THE NETWORK LOOOP!!!!")
            self.robot.behaviour.stopBehavior("boot-config/animations/networkLoop")
            self.robot.behaviour.runBehavior("boot-config/animations/success", _async=True)
            time.sleep(1)  # wait so behavior can finish
        self.robot.behaviour.runBehavior(self.appName + "/movements/goToStand")
        #self.robot.awareness_on()

        # notify user that exercise is now starting
        self.robot.animated_say("^mode(contextual)I'm done calibrating!\\pau=500\\"
                                "I will show you some exercises now. Try to follow my movements!\\pau=400\\"
                                "^start(animations/Stand/BodyTalk/Speaking/BodyTalk_1)"
                                "Get ^mode(disabled) ready! ^mode(disabled) Let's go!")
        #self.robot.awareness_off()

        # log intensity trend on Raspi
        # self.data_client.call_with_data("intensity", self.intensity_trend)

    def start_resting_phase(self):
            self.robot.animated_say("^mode(contextual)We are at the end of the first exercise cycle."
                                    "\\pau=300\\Before we continue, you should rest for 1 minute "
                                    "to bring your heart rate down.\\pau=300\\"
                                    "Close your eyes. Relax \\pau=200\\and enjoy the music!"
                                    "^mode(disabled)")
            self.logger.info("start resting!")
            self.robot.go_rest()
            self.robot.resting()
            self.robot.go_wake_up()
            self.logger.info("stop resting!")
            self.robot.animated_say("^mode(contextual)I hope you are well rested. \\pau=300\\"
                                    "Let's start another round of \\vct=105\\ exercises.")

    def say_goodbye(self):
        self.robot.awareness_on()
        self.robot.animated_say("^mode(contextual)We are at the end of our exercise session."
                                "\\pau=300\\ ^start(animations/Stand/Gestures/Hey_6)"
                                "Goodbye! and see you ^mode(disabled)soon", _async=True)
        self.robot.cute_eyes(4)

    def play_exercise(self, duration, exercise=None):
        if exercise is None:
            exercise = self.exercises[self.exercise_idx]

        # setup for motivational phrase
        say_motivational_phrase = bool(random.getrandbits(1))  # random true or false
        phrase_time = duration * (random.randint(55, 90) / 100.0)
        self.logger.info(phrase_time)

        # START EXERCISE
        self.robot.behaviour.runBehavior(self.appName + "/movements/" + exercise, _async=True)
        self.logger.info("started exercise!")
        time.sleep(phrase_time)

        # OPTIONAL MOTIVATIONAL PHRASE
        if say_motivational_phrase:
            self.robot.say(self.midex_motivational_phrases.pop())
        time.sleep(duration - phrase_time)
        self.logger.info(duration - phrase_time)

        # STOP EXERCISE
        self.robot.behaviour.stopBehavior(self.appName + "/movements/" + exercise)

        self.robot.behaviour.runBehavior(self.appName + "/movements/goToStand", _async=True)
        self.logger.info("stopped exercise!")

        # say something motivational at the end of the exercise
        self.robot.animated_say("^mode(contextual)" + random.choice(self.postex_motivational_phrases)
              + "^mode(disabled)\\pau=400\\")

    def stop_everything(self):
        # stop robot
        if not self.robot.is_virtual:
            # -- deactivate external collision avoidance
            self.robot.motion.setExternalCollisionProtectionEnabled("Arms", True)
            self.robot.stop_song()
            self.robot.cute_eyes()
            if self.robot.basic_awareness_on:
                self.robot.awareness_off()

            self.robot.tablet.hideWebview()
            #self.robot.tablet.hideImage()
            time.sleep(1)
            #self.robot.tablet.showImage(self.robot.image_path)
        self.logger.info("success")
        self.robot.stand()

    def evaluate_bpm(self):
        # copy last_bpm
        last_bpm = self.last_bpm
        last20_bpm = self.last20_bpm.mean()
        self.logger.info("last intensity:" + str(self.current_intensity))

        # evaluate if intensity should stay the same, go up or down
        if last_bpm < self.lower_bound_bpm:
            intensity_trend = 1  #UP
            #self.current_intensity = 1  # UP
            self.logger.info("BPM TOO LOW, faster exercise!")
        elif last_bpm > self.upper_bound_bpm:
            intensity_trend = -1  #DOWN
            #self.current_intensity = -1  # DOWN
            self.logger.info("BPM TOO HIGH, slower exercise!")
        else:
            intensity_trend = 0  #STAY
            #self.current_intensity = 0  # STAY
            self.logger.info("BPM PERFECT, keep doing what you are doing!")

        # set new exercise intensity (intesity can be 1, 2 or 3)
        new_intensity = self.current_intensity + intensity_trend

        if new_intensity > 3:
            new_intensity = 3
        elif new_intensity < 1:
            new_intensity = 1

        self.current_intensity = new_intensity
        self.logger.info("next intensity:" + str(self.current_intensity))

        # select new exercise
        if new_intensity == 1:
            # choose random easy exercise
            self.exercise_idx = self.easy_exerices.get_next_exercise()
        elif new_intensity == 2:
            # choose random medium exercise
            self.exercise_idx = self.medium_exercises.get_next_exercise()
        else:
            # choose random hard exercise
            self.exercise_idx = self.hard_exercises.get_next_exercise()

        # log intensity trend on Raspi
        self.data_client.call_with_data("intensity", intensity_trend)

    def end_session(self, is_last_session):
        # tell RasPi to end the session recording and if this was the last session
        self.data_client.call_with_data("done", is_last_session)



class ExerciseList():
    def __init__(self, logger, first_exercise_idx, last_exercise_idx, random_=False):
        self.logger = logger
        self.num_of_exercises = last_exercise_idx - first_exercise_idx + 1
        self.index = 0
        self.exercise_list = list(xrange(first_exercise_idx, last_exercise_idx + 1))  # ordered
        random.shuffle(self.exercise_list)  # randomly ordered list

    def get_next_exercise(self):
        next_exercise = self.exercise_list[self.index]
        self.index += 1

        if self.index >= self.num_of_exercises:
            random.shuffle(self.exercise_list)
            self.index = 0

        return next_exercise



class Pepper():
    def __init__(self, session, logger, behaviorAbsolutePath, virtual):
        self.behaviorAbsolutePath = behaviorAbsolutePath
        self.show_boundaries = True
        self.basic_awareness_on = False
        self.waiting_for_touch = True
        self.is_virtual = virtual
        self.session = session

        self.appName = ".lastUploadedChoregrapheBehavior"
        #appName = "pepper_tablet"
        self.image_path = "http://198.18.0.1/apps/" + self.appName + "/start_training_kleiner.png"

        # -- proxies
        self.logger = logger

        # these do not exist on the virtual robot
        if not self.is_virtual:
            self.tablet = self.session.service("ALTabletService")
            self.leds = ALProxy("ALLeds")
            self.autonomous_life = ALProxy("ALAutonomousLife")
            self.audio = self.session.service("ALAudioPlayer")
            self.audio_stopper = self.session.service("ALAudioPlayer")
            if self.basic_awareness_on:
                self.awareness = ALProxy("ALBasicAwareness")

        self.motion = ALProxy("ALMotion")
        self.posture = ALProxy("ALRobotPosture")
        self.speech = ALProxy("ALTextToSpeech")
        self.ani_speech = ALProxy("ALAnimatedSpeech")
        self.behaviour = self.session.service("ALBehaviorManager")

        self.stop_song()

        # -- speech volume
        self.speech.setVolume(1.0)

        if not self.is_virtual:
            # -- deactivate external collision avoidance
            self.motion.setExternalCollisionProtectionEnabled("Arms", False)

            # -- set basic awareness mode
            if self.basic_awareness_on:
                self.awareness.setEngagementMode("SemiEngaged")
                self.awareness.setTrackingMode("Head")

            # -- set init image
            self.tablet.setBackgroundColor("#ffffff")
            self.tablet.showImage(self.image_path)

            # -- load web application
            try:
                self.tablet.loadApplication(self.appName)
                self.logger.info("Successfully set application: %s" % self.appName)
                self.update_bpm(99)
                self.update_pulsewave(400)
            except Exception as e:
                print("Error was:", e)
                print("Failed to set application: %s" % self.appName)

            # -- enable touch listener
            connect_id = self.tablet.onTouchDown.connect(self.touch_callback)
        else:
            # -- don't wait to activate the program by clicking on tablet
            self.waiting_for_touch = False

    def touch_callback(self, x, y):
        if self.waiting_for_touch:
            self.waiting_for_touch = False
            print ("tablet was touched at x: " + str(x) + "  y: " + str(y))
            # self.tablet.hideImage()
            self.tablet.showWebview()

    def play_song(self, song):
        if not self.is_virtual:
            song_path = self.behaviorAbsolutePath + song
            self.logger.info("playing song: " + song_path)
            self.audio.playFile(song_path, 0.6, 0.0)

    def play_song_with_duration(self, song, duration):
        duration_left = 0

        if not self.is_virtual:
            song_path = self.behaviorAbsolutePath + song
            task_id = self.audio.loadFile(song_path)
            self.audio.play(task_id, 0.3, 0.0, _async=True)
            song_length = self.audio.getFileLength(task_id)
            if song_length <= duration:
                self.logger.info("playing song: " + song_path + " for seconds: " + str(song_length))
                self.logger.info("duration >= song")
                time.sleep(song_length)
                duration_left = duration - song_length
            else:
                self.logger.info("playing song: " + song_path + " for seconds: " + str(duration))
                self.logger.info("duration shorter than song")
                time.sleep(duration)

            self.stop_song()
            return duration_left

    def stop_song(self):
        # self.audio.stopAll()
        if not self.is_virtual:
            self.audio_stopper.stopAll()

    def say(self, text):
        self.speech.say(text)

    def animated_say(self, text, _async=False):
        if _async == False:
            self.ani_speech.say(text)
        else:
            self.ani_speech.post.say(text)
        #self.ani_speech.say(text, _async=_async)
        #self.do_exercise(post_exercise_motion(), _async=_async)

    def cute_eyes(self, duration=5):
        fade_duration = 0.05
        self.blink()
        self.leds.post.fadeRGB("FaceLed6", "magenta", fade_duration)
        self.leds.post.fadeRGB("FaceLed7", "magenta", fade_duration)
        time.sleep(duration)
        self.blink()

    def blink(self):
        rDuration = 0.05
        self.leds.post.fadeRGB( "FaceLed0", 0x000000, rDuration )
        self.leds.post.fadeRGB( "FaceLed1", 0x000000, rDuration )
        self.leds.post.fadeRGB( "FaceLed2", 0xffffff, rDuration )
        self.leds.post.fadeRGB( "FaceLed3", 0x000000, rDuration )
        self.leds.post.fadeRGB( "FaceLed4", 0x000000, rDuration )
        self.leds.post.fadeRGB( "FaceLed5", 0x000000, rDuration )
        self.leds.post.fadeRGB( "FaceLed6", 0xffffff, rDuration )
        self.leds.fadeRGB( "FaceLed7", 0x000000, rDuration )
        time.sleep( 0.1 )
        self.leds.fadeRGB( "FaceLeds", 0xffffff, rDuration )

    def update_bpm(self, bpm):
        if not self.is_virtual:
            self.tablet.executeJS("updates.updateBPM(" + str(bpm) + ")")

    def update_pulsewave(self, signal):
        if not self.is_virtual:
            self.tablet.executeJS("updates.updatePulseWave(" + str(signal) + ")")

    def stand(self):
        self.posture.goToPosture("Stand", 1)

    def go_rest(self):
        self.behaviour.runBehavior(self.appName + "/movements/go_rest")  #, _async=True)

    def go_wake_up(self):
        self.behaviour.runBehavior(self.appName + "/movements/go_wake_up")  #, _async=True)

    def resting(self):
        if not self.is_virtual:
            song_path = self.behaviorAbsolutePath + "/songs/PathOfTheWindPiano-FadeIn.wav"
            task_id = self.audio.loadFile(song_path)
            self.audio.play(task_id, 0.3, 0.0, _async=True)
            song_length = self.audio.getFileLength(task_id)
            self.logger.info("playing resting song for seconds: " + str(song_length))
            #self.breathing(song_length - 4)
            self.breathing2(10)
            self.stop_song()

    def breathing2(self, duration):
        self.behaviour.runBehavior(self.appName + "/movements/breathing", _async=True)
        time.sleep(duration)
        self.behaviour.stopBehavior(self.appName + "/movements/breathing")


    def breathing(self, duration):
        start = time.time()
        fractionMaxSpeed = 0.02

        angles = [-0.22, 0.11]
        RArmAngles = [0.15, -0.1, -0.1, -0.3]
        LArmAngles = [-0.15, -0.1, 0.1, -0.3]
        RArmAngles = [i * 0.5 for i in RArmAngles]
        LArmAngles = [i * 0.5 for i in LArmAngles]
        angles = [i * 0.5 for i in angles]

        while time.time() - start < (duration):
            # self.motion.setAngles(["HipPitch", "KneePitch"], angles, fractionMaxSpeed)
            self.motion.changeAngles(["RElbowRoll", "RShoulderPitch", "RShoulderRoll", "RHand"], RArmAngles,
                                     fractionMaxSpeed * 0.5)
            self.motion.changeAngles(["LElbowRoll", "LShoulderPitch", "LShoulderRoll", "LHand"], LArmAngles,
                                     fractionMaxSpeed * 0.5)
            self.motion.angleInterpolationWithSpeed(["HipPitch", "KneePitch"], angles, fractionMaxSpeed)
            time.sleep(2)
            if angles[0] < 0.0:
                angles = [0.0, 0.0]
            else:
                angles = [-0.18, 0.09]
                angles = [i * 0.8 for i in angles]
            RArmAngles = [x * -1.0 for x in RArmAngles]
            LArmAngles = [x * -1.0 for x in LArmAngles]

    def awareness_on(self):
        if self.basic_awareness_on:
            self.awareness.setEnabled(True)

    def awareness_off(self):
        if self.basic_awareness_on:
            self.awareness.setEnabled(False)


class DataClient():
    def __init__(self, logger, behaviorAbsolutePath, virtual, data_port, arg_port):
        self.logger = logger
        #if virtual:
        # self.ip = "127.0.0.1"
        #else:
        #self.ip = "192.168.1.104" # server is on local computer
        #self.ip = "192.168.1.101"  # server is on local computer - tp link pep wifi
        self.ip = "raspberrypi.local" # server is on raspberry pi
        #self.ip = "192.168.1.103"  # real robot

        self.data_port = data_port
        self.arg_port = arg_port

        self.data_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #self.data_sock.bind((self.ip, self.data_port))
        self.arg_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #self.arg_sock.setblocking(False) # Prevent socket from waiting for input
        #self.arg_sock.bind((self.ip, self.arg_port))

    def call_for(self, msg):
        self.logger.info("asking for " + msg)
        try:
            self.arg_sock.sendto(msg, (self.ip, self.arg_port))
            response = self.arg_sock.recv(1024)
            self.logger.info(response)
        except:
            self.logger.info("connection to raspi not available")

        return response

    def call_with_data(self, topic, data=None):
        #self.logger.info("asking for " + topic + " with data: " + str(data))

        msg = json.dumps([topic, data])
        try:
            self.arg_sock.sendto(msg.encode(), (self.ip, self.arg_port))
            #response = self.arg_sock.recv(1024)
            self.logger.info("sent " + topic + " with data: " + str(data))
        except:
            self.logger.info(topic + ": connection to raspi not available")

    def call_for_data(self):
        # self.logger.info("asking for data")
        try:
            self.data_sock.sendto("data", (self.ip, self.data_port))
            self.data_sock.settimeout(5.0)
            response = self.data_sock.recv(1024)
            # self.logger.info(response)

            bpm, pulse = json.loads(response)
            #data_msg = "BPM: " + str(bpm) + "  ---  pulse signal: " + str(pulse)
            #self.logger.info(data_msg)
            return bpm, pulse
        except:
            self.logger.info("data: connection to raspi not available")
            return [0, 0]]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box></ChoregrapheProject>